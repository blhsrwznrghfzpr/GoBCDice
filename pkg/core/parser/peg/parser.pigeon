{
	package peg_parser

	import (
		"github.com/raa0121/GoBCDice/pkg/core/ast"
		"github.com/raa0121/GoBCDice/pkg/core/token"
		"strconv"
		"strings"
	)
}

Command <- n:Calc EOT {
	return n.(ast.Node), nil
}

Calc <- calc:"C"i '(' expr:IntExpr ')' {
	exprNode := expr.(ast.Node)
	return ast.NewCalc(
		token.Token{
			Type: token.CALC,
			Literal: string(calc.([]byte)),
			Column: c.pos.col,
		},
		exprNode,
	), nil
}

IntExpr <- IntExprAdditive

IntExprAdditive <- first:IntExprMultitive rest:(('+' / '-') IntExprMultitive)* {
	lastNode := first.(ast.Node)
	for _, r := range rest.([]interface{}) {
		rs := r.([]interface{})
		op := string(rs[0].([]byte))
		right := rs[1].(ast.Node)

		switch op {
		case "+":
			tok := token.Token{Type: token.PLUS, Literal: op}
			lastNode = ast.NewAdd(lastNode, tok, right)
		case "-":
			tok := token.Token{Type: token.PLUS, Literal: op}
			lastNode = ast.NewSubtract(lastNode, tok, right)
		}
	}

	return lastNode, nil
}

IntExprMultitive <- first:IntExprPrimary rest:('/' IntExprPrimary [ur]i / (('*' / '/') IntExprPrimary))* {
	lastNode := first.(ast.Node)
	for _, r := range rest.([]interface{}) {
		rs := r.([]interface{})
		op := string(rs[0].([]byte))
		right := rs[1].(ast.Node)

		roundingMethod := ""
		if len(rs) >= 3 {
			roundingMethod = strings.ToUpper(string(rs[2].([]byte)))
		}

		switch op {
		case "*":
			tok := token.Token{Type: token.ASTERISK, Literal: op}
			lastNode = ast.NewMultiply(lastNode, tok, right)
		case "/":
			tok := token.Token{Type: token.SLASH, Literal: op}
			switch roundingMethod {
			case "U":
				lastNode = ast.NewDivideWithRoundingUp(lastNode, tok, right)
			case "R":
				lastNode = ast.NewDivideWithRounding(lastNode, tok, right)
			case "":
				lastNode = ast.NewDivideWithRoundingDown(lastNode, tok, right)
			}
		}
	}

	return lastNode, nil
}

IntExprPrimary <- Integer / IntExprUnaryPlus / IntExprUnaryMinus / IntExprParenthesize

IntExprParenthesize <- "(" e:IntExpr ")" {
	return e.(ast.Node), nil
}

IntExprUnaryPlus <- "+" e:IntExpr {
	return e.(ast.Node), nil
}

IntExprUnaryMinus <- "-" e:IntExprPrimary {
	tok := token.Token{Type: token.MINUS, Literal: "-"}
	return ast.NewUnaryMinus(tok, e.(ast.Node)), nil
}

Integer <- [0-9]+ {
	s := string(c.text)

	// TODO: 整数が大きすぎるときなどのエラー処理が必要
	value, _ := strconv.Atoi(s)

	return ast.NewInt(
		value,
		token.Token{
			Type: token.INT,
			Literal: s,
			Column: c.pos.col,
		},
	), nil
}

EOT <- !.
