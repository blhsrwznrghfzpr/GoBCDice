{
	package peg_parser

	import (
		"github.com/raa0121/GoBCDice/pkg/core/ast"
		"github.com/raa0121/GoBCDice/pkg/core/token"
		"strconv"
		"strings"
	)
}

Command <- n:Calc EOT {
	return n.(ast.Node), nil
}

Calc <- calc:"C"i '(' expr:IntExpr ')' {
	return ast.NewCalc2(expr.(ast.Node)), nil
}

IntExpr <- IntExprAdditive

IntExprAdditive <- first:IntExprMultitive rest:(('+' / '-') IntExprMultitive)* {
	lastNode := first.(ast.Node)
	for _, r := range rest.([]interface{}) {
		rs := r.([]interface{})
		op := string(rs[0].([]byte))
		right := rs[1].(ast.Node)

		switch op {
		case "+":
			lastNode = ast.NewAdd2(lastNode, right)
		case "-":
			lastNode = ast.NewSubtract2(lastNode, right)
		}
	}

	return lastNode, nil
}

IntExprMultitive <- first:IntExprPrimary rest:('/' IntExprPrimary [ur]i / (('*' / '/') IntExprPrimary))* {
	lastNode := first.(ast.Node)
	for _, r := range rest.([]interface{}) {
		rs := r.([]interface{})
		op := string(rs[0].([]byte))
		right := rs[1].(ast.Node)

		roundingMethod := ""
		if len(rs) >= 3 {
			roundingMethod = strings.ToUpper(string(rs[2].([]byte)))
		}

		switch op {
		case "*":
			lastNode = ast.NewMultiply2(lastNode, right)
		case "/":
			switch roundingMethod {
			case "U":
				lastNode = ast.NewDivideWithRoundingUp2(lastNode, right)
			case "R":
				lastNode = ast.NewDivideWithRounding2(lastNode, right)
			case "":
				lastNode = ast.NewDivideWithRoundingDown2(lastNode, right)
			}
		}
	}

	return lastNode, nil
}

IntExprPrimary <- Integer / IntExprUnaryPlus / IntExprUnaryMinus / IntExprParenthesize

IntExprParenthesize <- "(" e:IntExpr ")" {
	return e.(ast.Node), nil
}

IntExprUnaryPlus <- "+" e:IntExpr {
	return e.(ast.Node), nil
}

IntExprUnaryMinus <- "-" e:IntExprPrimary {
	return ast.NewUnaryMinus2(e.(ast.Node)), nil
}

Integer <- [0-9]+ {
	s := string(c.text)

	// TODO: 整数が大きすぎるときなどのエラー処理が必要
	value, _ := strconv.Atoi(s)

	return ast.NewInt2(value), nil
}

EOT <- !.
